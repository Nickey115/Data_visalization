<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rental Market Map</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="project.css">
    <style>
      
    </style>
  </head>
  <body>
    <div id="content">
      <div id="map"></div>
      <div id="sidepanel">
        <div id="filter">
          <h5>Filters</h5>
          <label class="form-label" for="county">County</label>
          <select
            id="county"
            class="form-select form-select-sm mb-3"
            multiple
            size="4"
          ></select>
          <label class="form-label" for="city">City</label>
          <select
            id="city"
            class="form-select form-select-sm mb-3"
            multiple
            size="4"
          ></select>
          <label class="form-label" for="property-type">Property Type</label>
          <select
            id="property-type"
            class="form-select form-select-sm mb-3"
            multiple
            size="3"
          >
            <option>Single-Family Home</option>
            <option>Townhome/Villa</option>
            <option>Condo</option>
          </select>
          <label class="form-label" for="rented-year">Rented Year</label>
          <input
            id="rented-year"
            type="number"
            class="form-control form-control-sm mb-3"
            placeholder="2024"
          />
          <label class="form-label" for="bedrooms">Bedrooms</label>
          <select id="bedrooms" class="form-select form-select-sm mb-3">
            <option value="">Any</option>
            <option>0</option>
            <option>1</option>
            <option>2</option>
            <option>3</option>
            <option>4-5</option>
            <option>6+</option>
          </select>
          <label class="form-label" for="sf-range">Square footage</label>
          <select id="sf-range" class="form-select form-select-sm mb-3">
            <option value="">Any</option>
            <option value="1000"> 1 000 sq ft</option>
            <option value="1000-2000">1 000–2 000 sq ft</option>
            <option value="2000-3000">2 000–3 000 sq ft</option>
            <option value="3000-4000">3 000–4 000 sq ft</option>
            <option value="4000-5000">4 000–5 000 sq ft</option>
            <option value=">5000">&gt; 5 000 sq ft</option>
          </select>
          <div id="pool-container" style="display: none">
            <label class="form-label" for="pool-filter">Private Pool</label>
            <select
              id="pool-filter"
              class="form-select form-select-sm mb-3"
            ></select>
          </div>
          <label class="form-label" for="waterfront-filter">Waterfront</label>
          <select
            id="waterfront-filter"
            class="form-select form-select-sm mb-3"
          ></select>
        </div>
        <div id="mls-list" class="mls-list"></div>
        <!-- <div class="compare-container">
          <h6>Compare Properties</h6>
          <div id="compare-selection" class="mb-2"></div>
          <div class="input-group input-group-sm">
            <input
              id="compare-mls-input"
              type="text"
              class="form-control"
              placeholder="MLS#"
            />
            <button id="add-to-compare" class="btn btn-primary">Add</button>
          </div>
          <button
            id="start-compare"
            class="btn btn-success btn-sm mt-2 me-2"
            disabled
          >
            Compare
          </button>
          <button
            id="clear-compare"
            class="btn btn-secondary btn-sm mt-2"
            disabled
          >
            Clear</button>
        </div> -->
      </div>
    </div>

    <div id="chart-container" style="display: none; margin: 20px 0; background: white; border: 1px solid #ddd; border-radius: 8px; padding: 20px;">
      <h3>Selected Area Analytics</h3>
      
      <div class="chart-overlay-controls">
        
        <div id="overlay-list"></div>        
        <div class="overlay-item" style="background: #e7e7eb; border-color: #0f1012;">
          <div class="overlay-label">Add Overlay:</div> 
          <div class="overlay-controls">
            <div class="checkbox-group"> 
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="new-furnished">
                <label class="form-check-label" for="new-furnished">Furnished</label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="new-full-baths">
                <label class="form-check-label" for="new-full-baths">Full Baths</label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="new-half-baths">
                <label class="form-check-label" for="new-half-baths">Half Baths</label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="new-waterfront">
                <label class="form-check-label" for="new-waterfront">Waterfront</label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="new-pool">
                <label class="form-check-label" for="new-pool">Pool</label>
              </div>
              <select id="new-garage" class="form-select form-select-sm">
                <option value="">Any Garage</option>
                <option value="0">No Garage</option>
                <option value="1">1 Garage</option>
                <option value="2">2 Garages</option>
                <option value="2+">2+ Garages</option>
              </select>
            </div> 
            <button id="add-overlay" class="btn btn-secondary btn-sm">Add</button> 
          </div>
        </div>
      </div>
      
      <div id="chart-legend" class="chart-legend"></div>
      
      <div style="display: grid; gap: 30px;">
        <div>
          <h4 id="price-chart-title" style="margin: 0 0 15px 0; text-align: center; color: #2c3e50;">Average Rented Price by Year</h4>
          <div id="price-chart" style="width: 100%; height: 400px;"></div>
        </div>
        
        <div>
          <h4 id="dom-chart-title" style="margin: 0 0 15px 0; text-align: center; color: #2c3e50;">Average Days on Market by Year</h4>
          <div id="dom-chart" style="width: 100%; height: 400px;"></div>
        </div>
      </div>
      
      <div style="margin-top: 20px; text-align: center;">
        <button id="clear-all-overlays" class="btn btn-secondary btn-sm">Clear All Overlays</button>
        <button id="reset-timeframe" class="btn btn-secondary btn-sm">Reset to Year View</button>
      </div>
    </div>
  </body>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
       // Global variables
       let allData = []; 
      let map; 
      let markerGroup; 
      let drawnItems; 

      // Chart related variables
      let selectedAreaData = []; 
      let currentTimeframe = 'year';
      let selectedYear = null; 

      // Chart overlay related variables
      let chartOverlays = []; 
      let overlayColors = [
        '#3498db', // Main Data
        '#e74c3c', 
        '#2ecc71', 
        '#f39c12', 
        '#9b59b6', 
        '#1abc9c', 
        '#e67e22', 
        '#34495e', 
        '#7f8c8d', 
        '#c0392b',
        '#d35400', 
        '#27ae60', 
        '#c8d6e5', 
        '#8e44ad', 
        '#2c3e50', 
        '#f1c40f', 
        '#7bdcb5'  
      ];
      let overlayCounter = 1; // Used to generate unique IDs for overlays
      
      /**
       * Initializes the Leaflet map.
       * Sets map center, tile layer, Leaflet.Draw controls, and marker group.
       */
      function initMap() {
        
        L.Browser.touch = false;

        // Initialize the map
        map = L.map("map").setView([25.7617, -80.1918], 12);
        // Add OpenStreetMap tile layer
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "© OpenStreetMap",
        }).addTo(map);

        // Initialize FeatureGroup to store user-drawn shapes
        drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        // Configure Leaflet.Draw controls, only allowing rectangle drawing here
        const drawControl = new L.Control.Draw({
          draw: {
            polygon: false, // Disable polygon drawing
            polyline: false, // Disable polyline drawing
            circle: false, // Disable circle drawing
            marker: false, // Disable marker drawing
            circlemarker: false, // Disable circle marker drawing
            rectangle: true // Enable rectangle drawing
          },
          edit: {
            featureGroup: drawnItems, // Allow users to edit drawn shapes
            remove: true
          }
        });
        map.addControl(drawControl);

        // Initialize marker group to manage all property markers on the map
        markerGroup = L.layerGroup().addTo(map);

        // Listen for the 'draw:created' event, triggered when the user finishes drawing a shape
        map.on('draw:created', function(e) {


          const type = e.layerType; // Get the type of drawn shape
          const layer = e.layer;     // Get the drawn shape's layer

          if (type === 'rectangle') { // If a rectangle was drawn

            const bounds = layer.getBounds(); // Get the geographic bounds (LatLngBounds) of the rectangle
            const selectedProperties = []; // Array to store selected property data
            
            console.log(`Selection bounds: ${bounds.toString()}`);
            console.log(`Total markers on map: ${markerGroup.getLayers().length}`);
            
            // Reset all marker styles to default blue
            markerGroup.eachLayer(marker => {
              marker.setIcon(L.icon({
                iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
                shadowSize: [41, 41]
              }));
            });

            let selectedCount = 0;
            markerGroup.eachLayer(marker => {
              const markerLatLng = marker.getLatLng(); 
              
              if (bounds.contains(markerLatLng)) { // Check if the marker is within the rectangle's bounds
                selectedCount++;
                console.log(`Marker within bounds: MLS# ${marker._mlsId}`);
                
                // Change the icon of the selected marker to red
                marker.setIcon(L.icon({
                iconUrl: 'ClickIcon.svg', // 紅色圖示
                iconSize: [50, 50],
                iconAnchor: [20, 40],
                popupAnchor: [0, -40],
                }));
                
                // Find the corresponding property data using the marker's ML#
                const mlsId = marker._mlsId;
                const property = allData.find(item => item['ML#'] === mlsId);
                if (property) {
                  selectedProperties.push(property); // Add property data to the selected list
                  console.log(`Found corresponding property data: ${property.Address}`);
                } else {
                  console.warn(`Property data not found for MLS# ${mlsId}`);
                }
              }
            });

            // If properties were selected, update the MLS list and display charts
            if (selectedProperties.length > 0) {
              updateMLSList(selectedProperties); 
              
              selectedAreaData = selectedProperties;
              showChartContainer(); // Show chart container
              
              // Reset time frame and overlays, then update charts
              currentTimeframe = 'year';
              selectedYear = null;
              chartOverlays = []; // Clear all overlays
              overlayCounter = 1; // Reset overlay counter
              updateOverlayList(); // Update overlay list display
              updateChartLegend(); // Update chart legend
              updateAnalyticsCharts(); // Update charts

              alert(`Selected ${selectedProperties.length} properties`);
            } else {
              alert("No properties found within the selected area");
            }
            
            drawnItems.addLayer(layer); 
            
          }
        });

      }
      // Initialize the map after the DOM content is fully loaded
      document.addEventListener('DOMContentLoaded', initMap);
      
      function updateMLSList(data) {
        const listDiv = document.getElementById("mls-list");
        listDiv.innerHTML = ""; 
        
        data.forEach((it) => {
          const div = document.createElement("div");
          div.className = "mls-item";
          div.textContent = it["ML#"];
          div.onclick = async () => {
            try {
              // Copy MLS# to clipboard on click
              await navigator.clipboard.writeText(it["ML#"]);
              alert("Copied " + it["ML#"] + " to clipboard");
            } catch (err) {
              console.error("Copy failed:", err);
              // Fallback for older browsers or if clipboard API fails
              const textArea = document.createElement("textarea");
              textArea.value = it["ML#"];
              document.body.appendChild(textArea);
              textArea.select();
              document.execCommand('copy');
              document.body.removeChild(textArea);
              alert("Copied " + it["ML#"] + " to clipboard (fallback)");
            }
            
            try {
              // Attempt to geocode address and locate the marker on the map
              const [lat, lon] = await geocodeAddress(it.Address);
              markerGroup.eachLayer((m) => {
                const markerLatLng = m.getLatLng();
                // Check if marker's lat/lng matches geocoded result (allowing for tiny floating point errors)
                if (Math.abs(markerLatLng.lat - lat) < 0.0001 && Math.abs(markerLatLng.lng - lon) < 0.0001) {
                  // Call marker's click event handler to update info and highlight
                  onMarkerClick.call(m, { target: m, latlng: m.getLatLng() });
                }
              });
            } catch (err) {
              console.warn(`Could not geocode or locate address: ${it.Address}`, err);
            }
          };
          listDiv.append(div);
        });
      }
      
      /**
       * Handles map marker click events.
       * @param {Object} e - Event object.
       */
      function onMarkerClick(e) {
        map.setView(e.latlng, 17, { animate: true }); // Set map view to marker location and zoom
        e.target.openPopup(); // Open the marker's popup
      }

      /**
       * Converts an address to latitude and longitude.
       * @param {string} address - The address string to geocode.
       * @returns {Promise<[number, number]>} - A Promise containing [latitude, longitude].
       */
      async function geocodeAddress(address) {
        const clean = address.replace(/\s+Unit.*$/i, ""); // Clean address string
        const res = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
            clean
          )}`
        );
        const arr = await res.json();
        if (!arr.length) throw new Error("No geocode"); // Throw error if no results
        return [parseFloat(arr[0].lat), parseFloat(arr[0].lon)]; // Return lat/lng
      }

      // Use PapaParse to load the CSV file
      Papa.parse("data.csv", {
        download: true, // Allow downloading from URL
        header: true, // Use the first row as headers
        delimiter: ";", // Set delimiter to semicolon (based on your CSV format)
        complete: (results) => {
          allData = results.data.filter((r) => r["ML#"]); // Filter out data without ML#
          initFilters(); // Initialize filters
          applyFilters(); // Apply initial filters
          // initCompare(); // Comparison feature is commented out in HTML
        },
      });

      /**
       * Initializes filter dropdowns.
       * Populates options for county, city, pool, waterfront, etc.
       */
      function initFilters() {
        const cSel = document.getElementById("county"),
          citySel = document.getElementById("city");
        // Populate county options
        [...new Set(allData.map((d) => d.County))].forEach((c) =>
          cSel.append(new Option(c, c))
        );
        // Populate city options
        [...new Set(allData.map((d) => d.City))].forEach((c) =>
          citySel.append(new Option(c, c))
        );
        
        const poolSel = document.getElementById("pool-filter");
        poolSel.append(new Option("Any", "")); // Add "Any" option
        // Populate pool options
        [...new Set(allData.map((d) => d["Pool YN"]).filter(Boolean))].forEach(
          (v) => poolSel.append(new Option(v === "Yes" ? "Pool" : "No Pool", v))
        );
        
        const wfSel = document.getElementById("waterfront-filter");
        wfSel.append(new Option("Any", "")); // Add "Any" option
        // Populate waterfront options
        [
          ...new Set(
            allData.map((d) => d["Waterfront Property (Y/N)"]).filter(Boolean)
          ),
        ].forEach((v) =>
          wfSel.append(new Option(v === "Yes" ? "On Water" : "Not On Water", v))
        );
        
        // Add 'change' event listeners to all filters to apply filters when values change
        [
          "county",
          "city",
          "property-type",
          "rented-year",
          "bedrooms",
          "sf-range",
          "pool-filter",
          "waterfront-filter",
        ].forEach((id) =>
          document.getElementById(id).addEventListener("change", applyFilters)
        );
        
        // Special handling for property type filter to show/hide pool filter
        document
          .getElementById("property-type")
          .addEventListener("change", () => {
            const showPool = [
              ...document.getElementById("property-type").selectedOptions,
            ].some((o) => o.value === "Single-Family Home");
            document.getElementById("pool-container").style.display = showPool
              ? "block"
              : "none";
            applyFilters(); // Apply filters
          });
      }

      /**
       * Applies filters based on current filter settings.
       * Filters `allData` and updates map markers and list.
       */
      function applyFilters() {
        const selC = [...document.getElementById("county").selectedOptions].map(
            (o) => o.value
          ),
          selCity = [...document.getElementById("city").selectedOptions].map(
            (o) => o.value
          ),
          selT = [
            ...document.getElementById("property-type").selectedOptions,
          ].map((o) => o.value),
          y = document.getElementById("rented-year").value,
          b = document.getElementById("bedrooms").value,
          sf = document.getElementById("sf-range").value,
          pool = document.getElementById("pool-filter").value,
          wf = document.getElementById("waterfront-filter").value;
        
        const filtered = allData.filter((item) => {
          if (selC.length && !selC.includes(item.County)) return false;
          if (selCity.length && !selCity.includes(item.City)) return false;
          if (selT.length && !selT.includes(item["Property Type"]))
            return false;
          if (y) {
            const d = new Date(item["Rented Date"]);
            if (isNaN(d) || d.getFullYear().toString() !== y) return false;
          }
          if (b && !matchRange(+item.Bedrooms, b)) return false;
          if (sf && !matchRange(+item["Square feet"], sf)) return false;
          if (
            document.getElementById("pool-container").style.display ===
              "block" &&
            pool &&
            item["Pool YN"] !== pool
          )
            return false;
          if (wf && item["Waterfront Property (Y/N)"] !== wf) return false;
          return true;
        });
        renderMap(filtered); // Render map markers
        renderList(filtered); // Render MLS list
      }

      /**
       * Checks if a value matches a range rule.
       * @param {number} val - The value to check.
       * @param {string} rule - The range rule string (e.g., "1000-2000", "2+", ">5000").
       * @returns {boolean} - True if the value matches the rule, false otherwise.
       */
      function matchRange(val, rule) {
        if (rule.includes("-")) {
          const [min, max] = rule.split("-").map(Number);
          return val >= min && val <= max;
        }
        if (rule.endsWith("+")) return val >= parseInt(rule);
        if (rule.startsWith("<")) return val < parseFloat(rule.slice(1));
        if (rule.startsWith(">")) return val > parseFloat(rule.slice(1));
        return val === parseFloat(rule);
      }

      /**
       * Renders markers on the map.
       * @param {Array<Object>} data - Array of property data to render.
       */
      async function renderMap(data) {
        // Clear all existing markers from the marker group
        if (markerGroup) {
          markerGroup.clearLayers();
        }
        
        for (const it of data) {
          try {
            // Geocode the address to get latitude and longitude
            const [lat, lon] = await geocodeAddress(it.Address);
            // Create popup content
            const popupContent = `<b>MLS#: ${it["ML#"]}</b><br>List: ${it["List Price"]}<br>Rented: ${it["Rented Price"]} (${it["Rented Date"]})<br>Beds: ${it.Bedrooms}, Baths: ${it["Full Baths"]}/${it["Half baths"]}<br>SF: ${it["Square feet"]}<br>Pool: ${it["Pool YN"]}<br>Waterfront: ${it["Waterfront Property (Y/N)"]}<br>${it.Address}`;
            
            // 3) 取出該筆資料的 "Calculated DOM"，並轉成數字
      const domRaw = it['ADOM'] || '0';
      const domValue = parseFloat(domRaw.toString().replace(/,/g, '')) || 0;

      // 4) 根據 domValue 決定矩形小塊的高度
      let rectHeight = 0;
      if (domValue > 92)       { rectHeight = 32; }
      else if (domValue > 63)  { rectHeight = 24; }
      else if (domValue > 45)  { rectHeight = 16; }
      else if (domValue > 31)  { rectHeight = 8; }

      // 5) 用 L.divIcon 建立一個帶綠色矩形的動態 icon
      const defaultIcon = L.divIcon({
        className: '',  // 如果需要自訂 CSS class，可自行填寫
        html: `
          <div style="
            width: 40px;
            height: ${40 + rectHeight}px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
            margin: 0;
          ">
            <img src="DefaultIcon.svg" style="
              width: 40px;
              height: 40px;
              display: block;
              margin: 0;
              padding: 0;
            " />
            <div style="
              width: 27.2px;
              height: ${rectHeight}px;
              background-color: #439638;
              margin-top: -6px;
            "></div>
          </div>
        `,
        iconAnchor: [20, 40 + rectHeight],       // 底部中心為錨點
        popupAnchor: [0, -(40 + rectHeight)],    // Popup 往上偏移對齊
      });

            // Create marker and bind popup and click event
            const marker = L.marker([lat, lon], { icon: defaultIcon })
              .bindPopup(popupContent)
              .on("click", onMarkerClick);
            
            // Important: Store MLS# on the marker object for later identification
            marker._mlsId = it["ML#"];
            
            // Add the marker to the markerGroup
            markerGroup.addLayer(marker);
            
          } catch(e) {
            console.warn(`Could not geocode address: ${it.Address}`, e);
          }
        }
      }

      /**
       * Renders properties in the MLS list.
       * @param {Array<Object>} data - Array of property data to render.
       */
      function renderList(data) {
        const listDiv = document.getElementById("mls-list");
        listDiv.innerHTML = ""; // Clear existing list
        data.forEach((it) => {
          const div = document.createElement("div");
          div.className = "mls-item";
          div.textContent = it["ML#"];
          div.onclick = async () => {
            try {
              await navigator.clipboard.writeText(it["ML#"]);
              alert("Copied " + it["ML#"] + " to clipboard");
            } catch (err) {
              console.error("Copy failed:", err);
              // Fallback for older browsers or if clipboard API fails
              const textArea = document.createElement("textarea");
              textArea.value = it["ML#"];
              document.body.appendChild(textArea);
              textArea.select();
              document.execCommand('copy');
              document.body.removeChild(textArea);
              alert("Copied " + it["ML#"] + " to clipboard (fallback)");
            }
            try {
              const [lat, lon] = await geocodeAddress(it.Address);
              // Iterate through markers in markerGroup to find a match and trigger click event
              markerGroup.eachLayer((m) => {
                const markerLatLng = m.getLatLng();
                if (Math.abs(markerLatLng.lat - lat) < 0.0001 && Math.abs(markerLatLng.lng - lon) < 0.0001) {
                  onMarkerClick.call(m, { target: m, latlng: m.getLatLng() });
                }
              });
            } catch (err) {
              console.warn(`Could not geocode or locate address: ${it.Address}`, err);
            }
          };
          listDiv.append(div);
        });
      }

      /**
       * Initializes the property comparison feature.
       */
      // function initCompare() {
      //   let compareList = [];
      //   const inp = document.getElementById("compare-mls-input");
      //   document.getElementById("add-to-compare").onclick = () => {
      //     const m = inp.value.trim();
      //     if (m && !compareList.includes(m)) compareList.push(m);
      //     update();
      //     inp.value = "";
      //   };
      //   document.getElementById("start-compare").onclick = () => {
      //     if (compareList.length > 1)
      //       window.open(
      //         "comparison.html?mls=" + compareList.join(","),
      //         "_blank"
      //       );
      //   };
      //   document.getElementById("clear-compare").onclick = () => {
      //     compareList = [];
      //     update();
      //   };
      //   function update() {
      //     const sel = document.getElementById("compare-selection");
      //     sel.innerHTML = "";
      //     compareList.forEach((m) => {
      //       const badge = document.createElement("span");
      //       badge.className = "badge bg-primary me-1";
      //       badge.textContent = m;
      //       sel.append(badge);
      //     });
      //     document.getElementById("start-compare").disabled =
      //       compareList.length < 2;
      //     document.getElementById("clear-compare").disabled =
      //       compareList.length === 0;
      //   }
      // }

      /**
       * Shows the chart container.
       */
      function showChartContainer() {
        document.getElementById('chart-container').style.display = 'block';
      }

      /**
       * Hides the chart container.
       */
      function hideChartContainer() {
        document.getElementById('chart-container').style.display = 'none';
      }

      /**
       * Filters `selectedAreaData` based on current filter conditions.
       * @returns {Array<Object>} - Filtered data array.
       */
      function getFilteredData() {
        // In project_2.html, the main data is typically selectedAreaData.
        // Overlay filtering logic is handled in createOverlayData.
        // This function might not be directly used in project_2.html,
        // as updateAnalyticsCharts directly processes selectedAreaData.
        // However, for consistency, additional global filters can be added here if needed.
        return selectedAreaData;
      }

      /**
       * Parses a date string into a Date object.
       * Supports "DD.MM.YYYY" and "MM/DD/YYYY" formats.
       * @param {string} dateStr - The date string.
       * @returns {Date|null} - The parsed Date object or null.
       */
      function parseDate(dateStr) {
        if (!dateStr) return null;
        let parsedDate = null;

        // Try to parse DD.MM.YYYY format (e.g., 26.03.2024)
        if (dateStr.includes('.')) {
          const parts = dateStr.split('.');
          if (parts.length === 3) {
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed
            const year = parseInt(parts[2], 10);
            parsedDate = new Date(year, month, day);
          }
        }        
        
        if (parsedDate && !isNaN(parsedDate.getTime())) {
          return parsedDate;
        } else {
          console.warn('Could not parse date string:', dateStr);
          return null;
        }
      }

      /**
       * Processes raw property data, aggregating it into average price and DOM data for charts.
       * @param {Array<Object>} data - Array of raw property data.
       * @returns {Array<Object>} - Aggregated chart data.
       */
      function processDataForCharts(data) {
        const processedData = {};
        
        data.forEach(item => {
          // Parse date
          const rentedDate = parseDate(item['Rented Date']);
          
          if (!rentedDate) {
            console.warn('Could not parse rental date:', { rentedDate: item['Rented Date'], mlsId: item['ML#'] });
            return;
          }
          
          // Parse price - handle strings that may contain '$' or commas
          let rentedPriceStr = item['Rented Price']?.toString() || '';
          rentedPriceStr = rentedPriceStr.replace(/[$,\s]/g, ''); // Remove '$', commas, and spaces
          let rentedPrice = parseFloat(rentedPriceStr);
          
          // Handle cases where a dot might be a thousands separator (e.g., 1.875 actually means 1875)
          if (rentedPriceStr.includes('.') && rentedPriceStr.split('.')[1].length === 3) {
              rentedPrice = parseFloat(rentedPriceStr.replace('.', ''));
          } else {
              rentedPrice = parseFloat(rentedPriceStr);
          }

          // Parse ADOM (Average Days on Market)
          const dom = parseInt(item['ADOM'], 10);
          
          // Check if parsed numerical values are valid
          if (isNaN(rentedPrice) || rentedPrice <= 0 || isNaN(dom)) {
            console.warn('Invalid/failed to parse rental price or DOM:', {
              originalPrice: item['Rented Price'],
              processedPrice: rentedPrice,
              originalDOM: item['ADOM'],
              processedDOM: dom,
              mlsId: item['ML#']
            });
            return;
          }
          
          let timeKey;
          if (currentTimeframe === 'year') {
            timeKey = rentedDate.getFullYear().toString();
          } else if (currentTimeframe === 'month' && selectedYear) {
            if (rentedDate.getFullYear() === selectedYear) {
              timeKey = (rentedDate.getMonth() + 1).toString(); // Month is 1-indexed
            } else {
              return; // Skip data not in the selected year
            }
          } else {
            return; // Data not matching the time frame
          }
          
          if (!processedData[timeKey]) {
            processedData[timeKey] = {
              prices: [],
              doms: [],
              count: 0
            };
          }
          
          processedData[timeKey].prices.push(rentedPrice);
          processedData[timeKey].doms.push(dom);
          processedData[timeKey].count++;
        });
        
        // Calculate averages and sort
        const result = [];
        Object.keys(processedData).sort((a, b) => parseInt(a) - parseInt(b)).forEach(key => {
          const data = processedData[key];
          const avgPrice = data.prices.reduce((sum, price) => sum + price, 0) / data.prices.length;
          const avgDOM = data.doms.reduce((sum, dom) => sum + dom, 0) / data.doms.length;
          
          result.push({
            period: key,
            avgPrice: Math.round(avgPrice),
            avgDOM: Math.round(avgDOM),
            count: data.count
          });
        });
        
        return result;
      }

      /**
       * Updates the analytics charts.
       * Processes main data and all overlay data, then calls redrawCharts to draw.
       */
      function updateAnalyticsCharts() {
        // 1. Process main data (data within the selected area, without overlay filters applied)
        let mainChartData = processDataForCharts(selectedAreaData);

        // 2. Process overlay data
        // The allChartData object will contain 'main' data and all 'overlay-X' data
        let allChartData = { 'main': mainChartData }; 
        chartOverlays.forEach((overlay) => { // Iterate through chartOverlays
          // Regenerate data for each overlay to ensure correct data when time frame changes
          overlay.data = createOverlayData(overlay.filters); 
          allChartData[`overlay-${overlay.id}`] = overlay.data; // Use overlay.id as key
        });

        console.log('All chart data (including overlays):', allChartData);

        // Check if there is any data to display (at least one dataset is not empty)
        const hasAnyData = Object.values(allChartData).some(dataset => dataset.length > 0);

        if (!hasAnyData) {
          d3.select("#price-chart").html('<div style="text-align: center; padding: 50px; color: #666;">No data available. Please try adjusting filters or selection area.</div>');
          d3.select("#dom-chart").html('<div style="text-align: center; padding: 50px; color: #666;">No data available. Please try adjusting filters or selection area.</div>');
          return;
        }
        
        // Update chart titles
        const timeLabel = currentTimeframe === 'year' ? 'Year' : `Month (${selectedYear})`;
        document.getElementById('price-chart-title').textContent = `Average Rented Price (${timeLabel}) - Comparison`;
        document.getElementById('dom-chart-title').textContent = `Average Days on Market (${timeLabel}) - Comparison`;
        
        // Call redrawCharts to draw all chart layers
        redrawCharts(allChartData);
      }

      /**
       * Redraws all chart layers (main data and overlays).
       * @param {Object} allChartData - Object containing all data layers.
       */
      function redrawCharts(allChartData) {
        // Clear existing charts
        d3.select("#price-chart").selectAll("*").remove();
        d3.select("#dom-chart").selectAll("*").remove();

        // Draw price chart (line chart)
        drawOverlayLineChart({
          data: allChartData,
          element: '#price-chart',
          xKey: 'period',
          yKey: 'avgPrice',
          yAxisLabel: 'Average Rented Price ($)',
          timeframe: currentTimeframe,
          onClick: timeframeClickHandler,
          colors: overlayColors // Pass color array
        });

        // Draw DOM chart (bar chart)
        drawOverlayBarChart({
          data: allChartData,
          element: '#dom-chart',
          xKey: 'period',
          yKey: 'avgDOM',
          yAxisLabel: 'Average Days on Market (Days)',
          timeframe: currentTimeframe,
          onClick: timeframeClickHandler,
          colors: overlayColors // Pass color array
        });

        updateChartLegend(); // Update legend
      }

      /**
       * Handles click events for time frame switching.
       * @param {string} period - The clicked period (year or month).
       */
      function timeframeClickHandler(period) {
        if (currentTimeframe === 'year') {
          selectedYear = parseInt(period);
          currentTimeframe = 'month';
          // Recalculate monthly data for all overlays as selectedYear has changed
          chartOverlays.forEach(ovl => {
            ovl.data = createOverlayData(ovl.filters);
          });
          updateAnalyticsCharts(); // Update charts again
        }
      }

      /**
       * Draws a multi-layer line chart (for Rented Price).
       * @param {Object} options - Object containing chart settings.
       */
      function drawOverlayLineChart(options) {
        const { data, element, xKey, yKey, yAxisLabel, timeframe, onClick, colors } = options;
        
        const container = d3.select(element);
        const containerRect = container.node().getBoundingClientRect();
        const margin = {top: 20, right: 30, bottom: 60, left: 100};
        const width = containerRect.width - margin.left - margin.right;
        const height = 400 - margin.top - margin.bottom;
        
        const svg = container
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);
        
        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Get all periods across all datasets (X-axis domain)
        const allPeriods = [...new Set(Object.values(data).flatMap(dataset => dataset.map(d => d[xKey])))].sort((a, b) => parseInt(a) - parseInt(b));
        // Get value range across all datasets (Y-axis domain)
        const allValues = Object.values(data).flatMap(dataset => dataset.map(d => d[yKey]));
        
        // Set scales
        const xScale = d3.scalePoint()
          .domain(allPeriods)
          .range([0, width])
          .padding(0.1);
        
        const yScale = d3.scaleLinear()
          .domain(d3.extent(allValues)) // Use min/max from all data
          .nice()
          .range([height, 0]);
        
        // Add X-axis
        g.append("g")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(xScale))
          .append("text")
          .attr("x", width / 2)
          .attr("y", 45)
          .attr("fill", "black")
          .style("text-anchor", "middle")
          .text(timeframe === 'year' ? 'Year' : 'Month');
        
        // Y-axis formatting - currency for price, plain for others
        const yAxisFormat = yKey === 'avgPrice' ? 
          d3.format("$,.0f") : d3.format(",.0f");
        
        // Add Y-axis
        g.append("g")
          .call(d3.axisLeft(yScale).tickFormat(yAxisFormat))
          .append("text")
          .attr("transform", "rotate(-90)")
          .attr("y", -80)
          .attr("x", -height / 2)
          .attr("fill", "black")
          .style("text-anchor", "middle")
          .text(yAxisLabel);
        
        // Draw lines and data points for each dataset
        for (const key in data) {
          const dataset = data[key];
          if (dataset.length === 0) continue; // Skip empty datasets

          let currentOverlayLabel = 'Main Data';
          let lineColor = colors[0]; // Default for Main Data
          
          if (key !== 'main') {
              const overlay = chartOverlays.find(ovl => `overlay-${ovl.id}` === key);
              if (overlay) {
                  currentOverlayLabel = overlay.label;
                  lineColor = overlay.color; // Use the fixed color from the overlay object
              }
          }

          const line = d3.line()
            .x(d => xScale(d[xKey]))
            .y(d => yScale(d[yKey]))
            .curve(d3.curveMonotoneX);
          
          g.append("path")
            .datum(dataset)
            .attr("fill", "none")
            .attr("stroke", lineColor)
            .attr("stroke-width", 3)
            .attr("d", line);
          
          g.selectAll(`.dot-${key}`)
            .data(dataset)
            .enter().append("circle")
            .attr("class", `dot-${key}`)
            .attr("cx", d => xScale(d[xKey]))
            .attr("cy", d => yScale(d[yKey]))
            .attr("r", 6)
            .attr("fill", lineColor)
            .style("cursor", "pointer")
            .on("click", function(event, d) {
              if (timeframe === 'year') {
                onClick(d.period); // Trigger time frame switch
              }
            })
            .on("mouseover", function(event, d) {
              const tooltip = d3.select("body").append("div")
                .attr("class", "chart-tooltip")
                .style("position", "absolute")
                .style("background", "rgba(0,0,0,0.8)")
                .style("color", "white")
                .style("padding", "10px")
                .style("border-radius", "4px")
                .style("font-size", "12px")
                .style("pointer-events", "none")
                .style("z-index", "1000");
              
              const formattedValue = yKey === 'avgPrice' ? 
                `$${d[yKey].toLocaleString()}` : d[yKey].toLocaleString();
              
              tooltip.html(`
                <strong>${currentOverlayLabel}</strong><br/>
                <strong>${timeframe === 'year' ? 'Year' : 'Month'}: ${d.period}</strong><br/>
                ${yAxisLabel}: ${formattedValue}<br/>
                Properties: ${d.count}
                ${timeframe === 'year' ? '<br/><em>Click to view months</em>' : ''}
              `)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
            })
            .on("mouseout", function() {
              d3.selectAll(".chart-tooltip").remove();
            });
        }
      }

      /**
       * Draws a multi-layer bar chart (for Average Days on Market DOM).
       * @param {Object} options - Object containing chart settings.
       */
      function drawOverlayBarChart(options) {
        const { data, element, xKey, yKey, yAxisLabel, timeframe, onClick, colors } = options;
        
        const container = d3.select(element);
        const containerRect = container.node().getBoundingClientRect();
        const margin = {top: 20, right: 30, bottom: 60, left: 80};
        const width = containerRect.width - margin.left - margin.right;
        const height = 400 - margin.top - margin.bottom;
        
        const svg = container
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);
        
        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Get all periods across all datasets (X-axis domain)
        const allPeriods = [...new Set(Object.values(data).flatMap(dataset => dataset.map(d => d[xKey])))].sort((a, b) => parseInt(a) - parseInt(b));
        // Get value range across all datasets (Y-axis domain)
        const allValues = Object.values(data).flatMap(dataset => dataset.map(d => d[yKey]));
        
        // Set scales
        const xScale = d3.scaleBand()
          .domain(allPeriods)
          .range([0, width])
          .padding(0.1);
        
        const yScale = d3.scaleLinear()
          .domain([0, d3.max(allValues)]) // DOM starts from 0
          .nice()
          .range([height, 0]);
        
        // Sub-scale for grouping multiple overlays within the same period
        const xSubScale = d3.scaleBand()
          .domain(Object.keys(data).map((_, i) => i.toString())) // Use index as domain for sub-scale
          .range([0, xScale.bandwidth()])
          .padding(0.05);
        
        // Add X-axis
        g.append("g")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(xScale))
          .append("text")
          .attr("x", width / 2)
          .attr("y", 45)
          .attr("fill", "black")
          .style("text-anchor", "middle")
          .text(timeframe === 'year' ? 'Year' : 'Month');
        
        // Add Y-axis
        g.append("g")
          .call(d3.axisLeft(yScale))
          .append("text")
          .attr("transform", "rotate(-90)")
          .attr("y", -60)
          .attr("x", -height / 2)
          .attr("fill", "black")
          .style("text-anchor", "middle")
          .text(yAxisLabel);
        
        let currentOverlayIndex = 0; // Use a separate index for colors
        // Draw bars for each dataset
        for (const key in data) {
          const dataset = data[key];
          if (dataset.length === 0) continue; // Skip empty datasets

          let currentOverlayLabel = 'Main Data';
          let barColor = colors[0]; // Default for Main Data
          
          if (key !== 'main') {
              const overlay = chartOverlays.find(ovl => `overlay-${ovl.id}` === key);
              if (overlay) {
                  currentOverlayLabel = overlay.label;
                  barColor = overlay.color; // Use the fixed color from the overlay object
              }
          }

          g.selectAll(`.bar-${key}`)
            .data(dataset)
            .enter().append("rect")
            .attr("class", `bar-${key}`)
            .attr("x", d => xScale(d[xKey]) + xSubScale(currentOverlayIndex.toString())) // Position using sub-scale
            .attr("width", xSubScale.bandwidth()) // Set width using sub-scale
            .attr("y", d => yScale(d[yKey]))
            .attr("height", d => height - yScale(d[yKey]))
            .attr("fill", barColor)
            .style("cursor", "pointer")
            .on("click", function(event, d) {
              if (timeframe === 'year') {
                onClick(d.period); // Trigger time frame switch
              }
            })
            .on("mouseover", function(event, d) {
              d3.select(this).attr("fill", d3.color(barColor).darker(0.5)); // Highlight effect
              
              const tooltip = d3.select("body").append("div")
                .attr("class", "chart-tooltip")
                .style("position", "absolute")
                .style("background", "rgba(0,0,0,0.8)")
                .style("color", "white")
                .style("padding", "10px")
                .style("border-radius", "4px")
                .style("font-size", "12px")
                .style("pointer-events", "none")
                .style("z-index", "1000");
              
              tooltip.html(`
                <strong>${currentOverlayLabel}</strong><br/>
                <strong>${timeframe === 'year' ? 'Year' : 'Month'}: ${d.period}</strong><br/>
                ${yAxisLabel}: ${d[yKey]} Days<br/>
                Properties: ${d.count}
                ${timeframe === 'year' ? '<br/><em>Click to view months</em>' : ''}
              `)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
            })
            .on("mouseout", function() {
              d3.select(this).attr("fill", barColor); // Restore color
              d3.selectAll(".chart-tooltip").remove(); // Remove tooltip
            });
          currentOverlayIndex++;
        }
      }

      /**
       * Creates data for an overlay based on filter conditions.
       * @param {Object} filters - Filter conditions for the overlay.
       * @returns {Array<Object>} - Processed overlay data.
       */
      function createOverlayData(filters) {
        let filteredData = selectedAreaData; // Start filtering from the current selected area data
        
        // Apply overlay filters
        if (filters.furnished) {
          filteredData = filteredData.filter(item => item['Furnished'] === 'Furnished');
        }
        if (filters.fullBaths) {
          filteredData = filteredData.filter(item => parseInt(item['Full Baths']) >= 1);
        }
        if (filters.halfBaths) {
          filteredData = filteredData.filter(item => parseInt(item['Half baths']) >= 1);
        }
        if (filters.garage && filters.garage !== '') {
          if (filters.garage === '2+') {
            filteredData = filteredData.filter(item => parseInt(item['Garage']) >= 2);
          } else {
            filteredData = filteredData.filter(item => item['Garage'] === filters.garage);
          }
        }
        if (filters.waterfront) {
          filteredData = filteredData.filter(item => item['Waterfront Property (Y/N)'] === 'Yes');
        }
        if (filters.pool) {
          filteredData = filteredData.filter(item => item['Pool YN'] === 'Yes');
        }
        
        // Use processDataForCharts to process the filtered data
        return processDataForCharts(filteredData);
      }

      /**
       * Generates a label for an overlay based on filter conditions.
       * @param {Object} filters - Filter conditions for the overlay.
       * @returns {string} - Generated label string.
       */
      function generateOverlayLabel(filters) {
        const labels = [];
        if (filters.furnished) labels.push('Furnished');
        if (filters.fullBaths) labels.push('Full Bath');
        if (filters.halfBaths) labels.push('Half Bath');
        if (filters.garage && filters.garage !== '') {
          if (filters.garage === '0') labels.push('No Garage');
          else if (filters.garage === '1') labels.push('1 Garage');
          else if (filters.garage === '2') labels.push('2 Garages');
          else if (filters.garage === '2+') labels.push('2+ Garages');
          else labels.push(`${filters.garage} Garage`); // Fallback
        }
        if (filters.waterfront) labels.push('Waterfront');
        if (filters.pool) labels.push('Pool');
        
        return labels.length > 0 ? labels.join(' + ') : 'All Properties';
      }

      /**
       * Adds a new chart overlay.
       */
      function addChartOverlay() {
        // Get current filter conditions from input fields
        const filters = {
          furnished: document.getElementById('new-furnished').checked,
          fullBaths: document.getElementById('new-full-baths').checked,
          halfBaths: document.getElementById('new-half-baths').checked,
          garage: document.getElementById('new-garage').value,
          waterfront: document.getElementById('new-waterfront').checked,
          pool: document.getElementById('new-pool').checked
        };
        
        // Check if at least one filter condition is selected
        const hasFilters = Object.values(filters).some(value => 
          value === true || (typeof value === 'string' && value !== '')
        );
        
        if (!hasFilters) {
          alert('Please select at least one filter condition');
          return;
        }
        
        // Create overlay data based on filters
        const overlayData = createOverlayData(filters);
        if (overlayData.length === 0) {
          alert('No data found for selected filters');
          return;
        }
        
        // Assign color based on the unique ID, cycling through overlayColors (excluding index 0)
        // This ensures a consistent color for a given overlay ID, even if others are removed.
        const assignedColor = overlayColors[(overlayCounter % (overlayColors.length - 1)) + 1];

        // Create new overlay object
        const overlay = {
          id: overlayCounter++, // Unique ID
          label: generateOverlayLabel(filters), // Generate label based on filters
          data: overlayData, // Overlay data
          color: assignedColor, // Assign a persistent color based on its ID
          filters: filters // Save filter conditions
        };
        
        chartOverlays.push(overlay); // Add overlay to array
        updateOverlayList(); // Update overlay list display
        updateChartLegend(); // Update legend
        updateAnalyticsCharts(); // Redraw charts to include new overlay
        
        resetOverlayControls(); // Reset overlay controls
      }

      /**
       * Updates the display of the overlay list.
       */
      function updateOverlayList() {
        const listDiv = document.getElementById('overlay-list');
        listDiv.innerHTML = ''; // Clear existing list
        
        chartOverlays.forEach(overlay => {
          const overlayDiv = document.createElement('div');
          overlayDiv.className = 'overlay-item';
          // Removed data points display
          overlayDiv.innerHTML = `
            <div class="overlay-label" style="color: ${overlay.color};">${overlay.label}</div>
            <div class="overlay-controls">
              <button class="btn btn-danger btn-sm" onclick="removeOverlay(${overlay.id})">Remove</button>
            </div>
          `;
          listDiv.appendChild(overlayDiv);
        });
      }

      /**
       * Updates the display of the chart legend.
       */
      function updateChartLegend() {
        const legendDiv = document.getElementById('chart-legend');
        legendDiv.innerHTML = ''; // Clear existing legend
        
        // Hide legend if no overlays
        if (chartOverlays.length === 0) {
          legendDiv.style.display = 'none';
          return;
        }
        
        legendDiv.style.display = 'flex'; // Show legend
        
        // Add legend item for main data
        const mainLegendItem = document.createElement('div');
        mainLegendItem.className = 'legend-item';
        mainLegendItem.innerHTML = `
          <div class="legend-color" style="background-color: ${overlayColors[0]};"></div>
          <span>Main Data</span>
        `;
        legendDiv.appendChild(mainLegendItem);

        // Add legend item for each overlay
        chartOverlays.forEach((overlay) => { // Iterate directly over overlays
          const legendItem = document.createElement('div');
          legendItem.className = 'legend-item';
          // Use the color assigned to the overlay object
          const color = overlay.color; 
          legendItem.innerHTML = `
            <div class="legend-color" style="background-color: ${color};"></div>
            <span>${overlay.label}</span>
          `;
          legendDiv.appendChild(legendItem);
        });
      }

      /**
       * Removes an overlay.
       * @param {number} overlayId - ID of the overlay to remove.
       */
      function removeOverlay(overlayId) {
        chartOverlays = chartOverlays.filter(overlay => overlay.id !== overlayId);
        updateOverlayList(); // Update overlay list
        updateChartLegend(); // Update legend
        updateAnalyticsCharts(); // Redraw charts
      }

      /**
       * Clears all overlays.
       * Resets overlay counter and redraws charts.
       */
      function clearAllOverlays() {
        chartOverlays = []; // Clear overlay array
        overlayCounter = 1; // Reset counter
        updateOverlayList(); // Update overlay list
        updateChartLegend(); // Update legend
        updateAnalyticsCharts(); // Redraw charts

        // Additionally, reset selected markers on the map to blue
        markerGroup.eachLayer(marker => {
            marker.setIcon(L.icon({
                iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
                shadowSize: [41, 41]
            }));
        });
        // Clear the drawn rectangle from the map
        drawnItems.clearLayers();
        // Hide the chart container
        hideChartContainer();
      }

      /**
       * Resets the input state of overlay controls.
       */
      function resetOverlayControls() {
        document.getElementById('new-furnished').checked = false;
        document.getElementById('new-full-baths').checked = false;
        document.getElementById('new-half-baths').checked = false;
        document.getElementById('new-garage').value = '';
        document.getElementById('new-waterfront').checked = false;
        document.getElementById('new-pool').checked = false;
      }

      // Add event listeners on DOMContentLoaded
      document.addEventListener('DOMContentLoaded', function() {
        // Reset Timeframe button
        document.getElementById('reset-timeframe').addEventListener('click', function() {
          currentTimeframe = 'year';
          selectedYear = null;
          updateAnalyticsCharts();
        });

        // Add Overlay button
        document.getElementById('add-overlay').addEventListener('click', addChartOverlay);
        // Clear All Overlays button
        document.getElementById('clear-all-overlays').addEventListener('click', clearAllOverlays);
      });
    </script>

</html>

